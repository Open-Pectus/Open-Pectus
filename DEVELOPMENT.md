Notes:

# Docker

To start all services in docker, run the following command from the `openpectus` directory:
`docker compose up --build` 

When the container is running, the aggregator services are available, including:
OpenAPI UI: http://localhost:8300/docs
OpenAPI spec: http://localhost:8300/openapi.json


## Flake
Flake is a python linter.

Run flake locally:
flake must be run from the proper directory in order to read its configuration. Otherwise it uses default
configuration which outputs many errors that are not relevant.

cd Open-Pectus\openpectus
flake8

## Diagram generation

To get started with diagram generation, run the following command from the `openpectus` directory:
`pyreverse -k .`
Pyreverse is installed as part of pylint (which is somehow already installed).


## Code generation from API spec

### Pectus UI and Aggregator API

The frontend generates typescript skeleton interfaces from the Aggregator API spec. 

To ensure compability between the implemented backend, the API specification file and the typescript interfaces all match, the flow for modification is as follows:
1. A change is made in the Aggregator API implementation.
2. The script update_api_spec_and_typescript.sh in manually invoked. This updates the api spec file and generates updated typescript interfaces from it. These changes should all be committed to git.
3. The frontend build uses the updated interfaces. If the frontend build fails, the whole build fails. This indicates an integration error caused by an incompatible API change. This should be fixed before the branch is merged, either by updating the frontend to support the API change or by reworking the API change to be compatible with the frontend.

To ensure that step 2. is not forgotten, the aggregator test suite contains a test that checks that generates a new api spec file and checks that it matches the spec file last generated by the script. If it doesn't, the test fails as does the aggregator build.

# Componets

## Pectus UI

This is a web application that allows users to view and interact with the Pectus system,
including runnings engines and process unit hardware attached to them.

## Aggregator

There is one Aggregator service in a pectus system. It has the following responsibilities:

- Manage Engine services via a web-socket protocol
- Expose the Pectus UI web client application to end users
- Expose a rest API for Pectus UI
- Expose a web-socket API for Pectus UI. Used for two-way features not feasible in rest API.
- Expose a Language Server Protocol web-socket API for the Pectus UI code editor
- Parse and analyze pectus code (requires no running engine, only knowledge of the UOD)

## Engine

An Engine service instance is required for each piece of process unit hardware. It has 
the following responsibilities:

- Communicate with the hardware
- Expose hardware state as Tags
- Expose hardware interaction as Commands
- Parse(?), analyze(?) and run pectus code

# Protocols


